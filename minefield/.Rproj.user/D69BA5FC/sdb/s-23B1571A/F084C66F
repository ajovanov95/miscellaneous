{
    "collab_server" : "",
    "contents" : "# adjacency matrix from grid of size m x m\n# graph has m x m vertices\n# 3x3 neighbourhood with full (including self loops) conectivity\nadjacency_matrix_from_grid <- function (m) {\n  v   <- m * m\n  adj <- matrix(rep(0, v * v), nrow = v)\n  \n  for (i in 0 : (m - 1)) \n  {\n    for (j in 0 : (m - 1)) \n    {\n        vind <- 1 + j + i * m;\n        \n        for (row in c(i - 1, i, i + 1)) \n        {\n            for (col in c(j - 1, j, j + 1)) \n            {\n                if (col >= 0 & col < m && row >= 0 && row < m) \n                {\n                    vneigh <- 1 + col + row * m;\n                  \n                    adj[vind, vneigh] <- 1;\n                }\n            }\n        }\n    }\n  }\n  \n  adj\n}\n\n# am : adjacency matrix\n# vertices are numbers from 1 to m x m row wise \n# density = number of outgoing edges\nmost_dense_vertex <- function(am) {\n  which.max (apply(am, 1, sum))\n}\n\n# am : adjacency matrix\nleast_dense_vertex <- function(am) {\n  which.min (apply(am, 1, sum))\n}\n\n# am : adjacency matrix\n# v  : vertex\nneighbours <- function(am, v) {\n  s <- dim(am)[1]\n  (1:s)[as.logical(am[v,])]\n}\n\nsimulate <- function(am, p) \n{\n    alive  <- rep(1, nrow(am))\n    nsteps <- 0\n    \n    zeros  <- rep(0, nrow(am))\n  \n    while (sum(alive) != 0) \n    {\n        v0       <- most_dense_vertex(am)\n      \n        neighs   <- neighbours(am, v0)\n        \n        nverts   <- length(alive)\n        \n        queue    <- neighs\n        \n        while (length(queue) > 0)\n        {\n          # following two lines are queue pop operation\n          q <- queue[1]\n          queue <- queue[-1]\n          \n          if (alive[q] == 1) \n          {\n            # destroy node q with probability p or destroy certainly if targeted\n            if (runif(1) <= p || q == v0) \n            {\n              # explode node q\n              alive[q]  <- 0\n              \n              # add all alive neighbours into queue for processing\n              neighs <- neighbours(am, q)\n              \n              for (n in neighs) \n              {\n                if (alive[n] == 1 && (n %in% queue) == F) \n                {\n                  queue <- append(queue, n)\n                }\n              }\n              \n              # delete all links from destroyed node\n              am[q, ] = zeros\n            }\n          }\n        }\n        \n        nsteps <- nsteps + 1\n    }\n    \n    nsteps\n}\n\n# SLOW SLOW SLOW\nsimulate_many <- function(am, p, n) {\n  sapply (1:n, function (x) { simulate (am, p) })\n}\n\nexpected_number_of_steps <- function(am, p) {\n  # simulate_many is slow, take care with this parameter\n  niter <- 200\n  \n  mean(simulate_many(am, p, niter))\n}\n\n# generate link between p and expected steps\ngenerate_link_p_expected_steps <- function(am, ofname = NULL) {\n  svl   <- 200\n  pstep <- 1.0 / svl \n  pvec  <- seq(0.0, 1.0, pstep)\n  \n  steps <- rep(0, svl)\n  \n  for (i in seq(along=pvec)) \n  {\n      p        <- pvec[i]\n      \n      steps[i] <- expected_number_of_steps(am, p)\n      \n      print (sprintf(\"Processing step [%d]\", i))\n  }\n  \n  if (is.null(ofname) == F)\n    write.csv(file=ofname, cbind(pvec, steps), row.names = F)\n  \n  cbind(pvec, steps)\n}\n\n# d = cbind(pvec, steps)\nget_params_for_exp_curve <- function(d) {\n  # least squares fit\n  lsf <- function(par) {\n    s1 <- par[1]\n    s2 <- par[2]\n    \n    a = (s2 * exp(-s1 * d[,1]))\n    b = d[,2]\n    sum((a - b) ^ 2)\n  }\n  \n  ores <- optim(par=c(0, 0), fn = lsf, \n                gr = NULL, method=c(\"BFGS\"), \n                lower = -Inf, upper = Inf, \n                control = list(), hessian = T)\n  \n  s1opt <- ores$par[1]\n  s2opt <- ores$par[2]\n  \n  sse   <- ores$value\n  \n  c(s1opt, s2opt, sse)\n}\n\n# Question 1: Is the p-nsteps curve exponential for every n\ntest_question1 <- function(N) {\n  # 3 koloni: s1, s2, sse\n  s1s  <- 1:N\n  s2s  <- 1:N\n  sses <- 1:N\n  \n  for (n in 1:N) \n  {\n      print(sprintf (\"Question 1 [%d] of [%d]\", n, N))\n    \n      am <- adjacency_matrix_from_grid(n)\n    \n      d <- generate_link_p_expected_steps(am, ofname=sprintf(\"minefield_steps/steps-%d.csv\", n))\n      \n      o <- get_params_for_exp_curve(d)\n      \n      s1s [n] <- o[1]\n      s2s [n] <- o[2]\n      sses[n] <- o[3]\n  }\n  \n  r <- cbind(s1s, s2s, sses)\n  colnames(r) <- c(\"S1\", \"S2\", \"SSE\")\n  \n  write.csv(r, file = sprintf('question1-%d.csv', N), row.names = F)\n}\n\n# Open questions:\n# 1.0. Is it always s2 * e^(-s1 * x) for quadratic minefields of any size n?\n# 1.1. Is there a way to find/estimate s1 and s2 from graph characterstics?\n\n# 3. What if we use least dense instead of most dense?\n# 4. Will it be same exponential for any graph in case p = const?\n# 5. What if probability of explosion propagation is not fixed?\n",
    "created" : 1493130482988.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3693598049",
    "id" : "F084C66F",
    "lastKnownWriteTime" : 1493131218,
    "last_content_update" : 1493131218367,
    "path" : "~/Projects/minefield/minefield.r",
    "project_path" : "minefield.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}